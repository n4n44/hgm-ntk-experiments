import numpy as np
import scipy
from .hgm import tmp_resin
from .hgm import hgm_batch_resin
from .ntk_activator import Activator
from .integrate import gauss_hermite_2D as ada_gh


class Resin(Activator):
    def __init__(self):
        super().__init__()
        self.hgm_large_covar = 1
        self.batch_init = np.array([[-1.0,1/100,-1.0, -1]])
    def activator(self,x):
        if x < 0:
            return 0
        else:
            return np.sin(x)

    def activator_dot(self,x):
        if x < 0:
            return 0
        else:
            return np.cos(x)
        

    def _closed_exp(self,covar):
        c1,c2,r = self._get_c1_c2_r(covar)
        return 0

    
    def _closed_exp_dot(self,covar):
        c1,c2,r = self._get_c1_c2_r(covar)
        return 0
    
    def _hgm_exp(self,covar):
        if np.linalg.det(covar) >= 0.000001:
            input_mat = -np.linalg.inv(covar)/2
            sigma =e_relu.e_relu([input_mat[0][0],input_mat[0][1],input_mat[1][1]])
        return sigma
            
    def _hgm_exp_dot(self,covar):
        return 0
    def _mc_exp(self,covar):
        return 0
    def _mc_exp_dot(self,covar):
        return 0
    def _closed_sigmas(self,covar):
        c1,c2,r = self._get_c1_c2_r(covar)
        sigma = ((r*(np.pi-np.arccos(np.max([np.min([r,1]),-1])))+np.sqrt(1-np.min([r*r,1])))*(c1*c2))/(2*np.pi)
        
        sigma_dot = (np.pi-np.arccos(np.max([np.min([r,1]),-1])))/(2*np.pi)
        
        var1 = (c1**2)/2
        var2 = (c2**2)/2
        return var1,var2,sigma,sigma_dot

    def _hgm_sigmas(self,covar,rtol = 1e-10,atol = 1e-10):
        c1,c2,r = self._get_c1_c2_r(covar)
        if np.linalg.det(covar) >= 1e-3:
            input_mat = -np.linalg.inv(covar)/2
            sigma =tmp_resin.e_resin([input_mat[0][0],input_mat[0][1],input_mat[1][1]],rtol = rtol,atol= atol)
            sigma_dot = tmp_resin.e_resin_diff([input_mat[0][0],input_mat[0][1],input_mat[1][1]],rtol = rtol,atol= atol)

            var1,var2,_,_ =  self._gauss_herm_sigmas(covar)

        else:
            var1,var2,sigma,sigma_dot = self._gauss_herm_sigmas(covar)

        return var1, var2, sigma, sigma_dot

    def _mc_sigmas(self,covar):
        c1,c2,_ = self._get_c1_c2_r(covar)
        sigma = 0
        sigma_dot = 0
        for j in range(self.mc_size):
            vec = np.random.multivariate_normal([0,0],covar)
            u = np.random.normal(0.,np.sqrt(covar[0][0]))
            v = np.random.normal(0.,np.sqrt(covar[1][1]))
            sigma += self.activator(vec[0])*self.activator(vec[1])
            sigma_dot += self.activator_dot(vec[0])*self.activator_dot(vec[1])
        sigma = sigma/self.mc_size
        sigma_dot = sigma_dot/self.mc_size
        var1 = (c1**2)/2
        var2 = (c2**2)/2
        return var1,var2,sigma,sigma_dot
        
    def batch_hgm(self,dat,qsize=-1,rtol = 1e-10,atol = 1e-10):
        sol = hgm_batch_resin.batch_hgm(dat,qsize,rtol,atol)
        return sol.y

    def batch_hgm_dot(self,dat,qsize=-1,rtol = 1e-10,atol = 1e-10):
        sol = hgm_batch_resin.batch_hgm_diff(dat,qsize,rtol,atol)
        return sol.y

    def _hgm_sigma(self,dat,rtol = 1e-10,atol = 1e-10):
        tmp_sol = tmp_resin.e_resin(dat[0:3],rtol,atol)
        return tmp_sol

    def _hgm_sigma_dot(self,dat,rtol = 1e-10,atol = 1e-10):
        tmp_diff_sol = tmp_resin.e_resin_diff(dat[0:3],rtol,atol)
        return tmp_diff_sol

    # def _gauss_herm_sigmas(self,covar):
    #     def resin_kernel
        
    #     x = np.linalg.inv(-covar/2)
    #     return integrate_
